<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogmarks (Posts about github)</title><link>https://chris48s.github.io/blogmarks/</link><description></description><atom:link href="https://chris48s.github.io/blogmarks/categories/github.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2023 chris48s</copyright><lastBuildDate>Tue, 03 Oct 2023 13:05:20 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Querying GitHub Repos in Bulk</title><link>https://chris48s.github.io/blogmarks/posts/2023/bulk-querying-github/</link><dc:creator>chris48s</dc:creator><description>&lt;p&gt;I've recently been working on a tool called &lt;a href="https://github.com/chris48s/pip-abandoned"&gt;pip-abandoned&lt;/a&gt;, which allows you to search for abandoned and deprecated python packages.&lt;/p&gt;
&lt;p&gt;In order to make this, one of the things I needed to do was fetch the &lt;code&gt;archived&lt;/code&gt; property for lots of GitHub repositories. Using the GitHub v3 (rest) API, this would need one round-trip per repo. So if I want to fetch the &lt;code&gt;archived&lt;/code&gt; property for&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/pygments/pygments"&gt;https://github.com/pygments/pygments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pycqa/mccabe"&gt;https://github.com/pycqa/mccabe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/readthedocs/commonmark.py"&gt;https://github.com/readthedocs/commonmark.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;then I need to make three API calls:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://api.github.com/repos/pygments/pygments"&gt;https://api.github.com/repos/pygments/pygments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://api.github.com/repos/pycqa/mccabe"&gt;https://api.github.com/repos/pycqa/mccabe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://api.github.com/repos/readthedocs/commonmark.py"&gt;https://api.github.com/repos/readthedocs/commonmark.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;..and if I had a list of 200 GitHub repos, that would require 200 individual network requests.&lt;/p&gt;
&lt;p&gt;Fortunately, GitHub also has a GraphQL API. Using the GraphQL API, we can query more than one repo in a single request. To fetch the same data as above using the GraphQL API, I can make the following query&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;query&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nl"&gt;pygments&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;repository&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;owner&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"pygments"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"pygments"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;isArchived&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nl"&gt;mccabe&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;repository&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;owner&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"pycqa"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"mccabe"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;isArchived&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nl"&gt;commonmark&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;repository&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;owner&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"readthedocs"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"commonmark.py"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;isArchived&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;to retrieve the &lt;code&gt;archived&lt;/code&gt; property for those three repos in a single round-trip over the network. When querying a large number of repos this is a big benefit.&lt;/p&gt;</description><category>github</category><guid>https://chris48s.github.io/blogmarks/posts/2023/bulk-querying-github/</guid><pubDate>Sun, 17 Sep 2023 23:00:00 GMT</pubDate></item><item><title>Composite Actions vs Reusable Workflows</title><link>https://chris48s.github.io/blogmarks/posts/2021/composite-actions-reusable-workflows/</link><dc:creator>chris48s</dc:creator><description>&lt;p&gt;A few days after I blogged about GitHub &lt;a href="https://docs.github.com/en/actions/creating-actions/creating-a-composite-action"&gt;Composite Actions&lt;/a&gt;, GitHub launched another similar feature: &lt;a href="https://docs.github.com/en/actions/learn-github-actions/reusing-workflows"&gt;Reusable Workflows&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There is a lot of overlap between these features and there are certainly some tasks that could be accomplished with either. Simultaneously, there are some important differences that drive a bit of a wedge between them.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A composite action is presented as one "step" when it is invoked in a workflow, even if the action yaml contains multiple steps. Invoking a reusable workflow presents each step separately in the summary output. This can make debugging a failed composite action run harder.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reusable workflows can use secrets, whereas a composite action can't. You have to pass secrets in as parameters. Reusable workflows are also always implicitly passed &lt;code&gt;secrets.GITHUB_TOKEN&lt;/code&gt;. This is often convenient, but another way to see this tradeoff would be to say: If you're using a reusable workflow published by someone else, it can always read your &lt;code&gt;GITHUB_TOKEN&lt;/code&gt; var with whatever scopes that is granted, which may not always be desirable. A composite action can only read what you explicitly pass it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Both can only take &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;boolean&lt;/code&gt; as a param. Arrays are not allowed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Only a &lt;a href="https://docs.github.com/en/actions/learn-github-actions/reusing-workflows#supported-keywords-for-jobs-that-call-a-reusable-workflow"&gt;subset of job keywords&lt;/a&gt; can be used when calling a reusable workflow. This places some restrictions on how they can be used. To give an example, reusable workflows can't be used with a matrix but composite actions can, so&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nt"&gt;jobs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;build&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;strategy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;param&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;[&lt;/span&gt;&lt;span class="s"&gt;'foo'&lt;/span&gt;&lt;span class="p p-Indicator"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;'bar'&lt;/span&gt;&lt;span class="p p-Indicator"&gt;]&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;uses&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;chris48s/my-reusable-workflow/.github/workflows/reuse-me.yml@main&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;with&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;param&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;${% raw %}{{ matrix.param }}{% endraw %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;will throw an error, but&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nt"&gt;jobs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;build&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;runs-on&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;ubuntu-latest&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;strategy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;param&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;[&lt;/span&gt;&lt;span class="s"&gt;'foo'&lt;/span&gt;&lt;span class="p p-Indicator"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;'bar'&lt;/span&gt;&lt;span class="p p-Indicator"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;steps&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;uses&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;chris48s/my-shared-action@main&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;with&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="nt"&gt;param&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;${% raw %}{{ matrix.param }}{% endraw %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;is valid&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;s&gt;Steps in a composite action can not use &lt;code&gt;if:&lt;/code&gt; conditions, although there are &lt;a href="https://github.com/actions/runner/issues/834"&gt;workarounds&lt;/a&gt;.&lt;/s&gt; &lt;strong&gt;Update&lt;/strong&gt;: Thanks to &lt;a href="https://github.com/bewuethr"&gt;@bewuethr&lt;/a&gt; who pointed out that composite actions &lt;a href="https://github.blog/changelog/2021-11-09-github-actions-conditional-execution-of-steps-in-actions/"&gt;now support conditionals&lt;/a&gt; ðŸŽ‰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A composite action is called as a job step so a job that calls a composite action can have other steps (including calling other composite actions). A job can only call one reusable workflow and can't contain other steps.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><category>github</category><guid>https://chris48s.github.io/blogmarks/posts/2021/composite-actions-reusable-workflows/</guid><pubDate>Sat, 06 Nov 2021 00:00:00 GMT</pubDate></item><item><title>GitHub Composite Actions</title><link>https://chris48s.github.io/blogmarks/posts/2021/composite-actions/</link><dc:creator>chris48s</dc:creator><description>&lt;p&gt;GitHub quietly sneaked out a new feature in the last few weeks: &lt;a href="https://docs.github.com/en/actions/creating-actions/creating-a-composite-action"&gt;Composite Actions&lt;/a&gt;. This solves one of my biggest issues with GH Actions which is that yaml workflow steps couldn't be re-used. This means I have lots of repos with the exact same yaml workflow, or roughly the same workflow with slight variations. For example these 3 repos (and others) currently use the exact same workflow for CI:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/chris48s/datapackage-to-datasette/blob/1db8e836f588d0d1b65fbef56bcfa4ccc79d871b/.github/workflows/test.yml"&gt;datapackage-to-datasette&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chris48s/commitment/blob/fa634b9e6c4291052af5160421274c194d5eef3e/.github/workflows/test.yml"&gt;commitment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chris48s/datasette-mailto-links/blob/705aae608f839fbdff787971957291ec01f30d3f/.github/workflows/test.yml"&gt;datasette-mailto-links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Composite actions essentially allows yaml workflow steps to be packaged and re-used in the same way that javascript actions or docker actions can be, so I can package this up as a shared action and use it in lots of repos. This is a feature I have been hoping would be added to Actions for some time and I'm looking forward to DRYing up my workflows across repos over the coming weeks.&lt;/p&gt;</description><category>github</category><guid>https://chris48s.github.io/blogmarks/posts/2021/composite-actions/</guid><pubDate>Sat, 11 Sep 2021 23:00:00 GMT</pubDate></item><item><title>Running a GitHub action on pull request merge</title><link>https://chris48s.github.io/blogmarks/posts/2021/gh-action-pr-merge/</link><dc:creator>chris48s</dc:creator><description>&lt;p&gt;Github workflows can be triggered by a variety of events. The &lt;code&gt;pull_request&lt;/code&gt; event has 14 different &lt;a href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request"&gt;activity types&lt;/a&gt;. I recently wanted to write an action that runs after a pull request is merged and I was surprised to find that &lt;code&gt;merged&lt;/code&gt; is not one of the supported activity types. This is easy enough to work around using the following snippet, but a surprising omission.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nt"&gt;on&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;pull_request&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;types&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;closed&lt;/span&gt;&lt;span class="p p-Indicator"&gt;]&lt;/span&gt;

&lt;span class="nt"&gt;jobs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;my-job&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;if&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;github.event.pull_request.merged == true&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;steps&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>github</category><guid>https://chris48s.github.io/blogmarks/posts/2021/gh-action-pr-merge/</guid><pubDate>Sun, 04 Apr 2021 23:00:00 GMT</pubDate></item></channel></rss>