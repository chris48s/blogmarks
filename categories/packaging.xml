<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogmarks (Posts about packaging)</title><link>https://chris48s.github.io/blogmarks/</link><description></description><atom:link href="https://chris48s.github.io/blogmarks/categories/packaging.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2025 chris48s</copyright><lastBuildDate>Sun, 11 May 2025 19:46:22 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>An analysis of python package manifest files</title><link>https://chris48s.github.io/blogmarks/posts/2024/python-package-manifest-files/</link><dc:creator>chris48s</dc:creator><description>&lt;p&gt;Python packaging is messy and fragmented. Lots of people have been writing about it recently and there have been some great articles that have attracted a lot of attention. For example, I've particularly enjoyed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://alpopkes.com/posts/python/packaging_tools/"&gt;An unbiased evaluation of environment management and packaging tools&lt;/a&gt; by Anna-Lena Popkes&lt;/li&gt;
&lt;li&gt;&lt;a href="https://chriswarrick.com/blog/2023/01/15/how-to-improve-python-packaging/"&gt;How to improve Python packaging, or why fourteen tools are at least twelve too many&lt;/a&gt; by Chris Warrick and&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pradyunsg.me/blog/2023/01/21/thoughts-on-python-packaging/"&gt;Thoughts on the Python packaging ecosystem&lt;/a&gt; by Pradyun Gedam&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gregory Szorc also captured the frustrating experience many developers face trying to navigate the modern python packaging landscape in &lt;a href="https://gregoryszorc.com/blog/2023/10/30/my-user-experience-porting-off-setup.py/"&gt;My User Experience Porting Off setup.py&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It is a topic I also spend a lot of time thinking about, but I decided to take a look at the topic from a slightly different angle. Instead of lamenting the proliferation of different tools, or attempting to round them all up and compare them, I decided to ask: What are package authors actually doing out there in the wild, and how is the community responding to this change and fragmentation?&lt;/p&gt;
&lt;p&gt;So I conducted a bit of research. I looked at a sample of 31,474 public GitHub repos associated with one or more python packages on PyPI and analysed the manifests to find out a bit more about how people are actually specifying their package metadata and building their packages. For the purposes of this research, I'm focussing on packages. You could probably ask and answer some similarly interesting questions about applications, but I haven't done it here. There's a bit more information about how and why I arrived at this sample of ~30k GitHub repos in the &lt;a href="https://chris48s.github.io/blogmarks/posts/2024/python-package-manifest-files/#methodology-notes"&gt;methodology notes&lt;/a&gt;, but I'm not going to bury the lead. Lets just jump straight into the good stuff.&lt;/p&gt;
&lt;h3&gt;Manifest files&lt;/h3&gt;
&lt;p&gt;I looked for the presence of 3 files: pyproject.toml, setup.py and setup.cfg. Most of the repos I looked at contained more than one.&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;File&lt;/th&gt;
    &lt;th&gt;Count&lt;/th&gt;
    &lt;th&gt;Percent&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;setup.py&lt;/td&gt;
    &lt;td class="right-align"&gt;20,684&lt;/td&gt;
    &lt;td class="percent" style="background-size: 66% 100%"&gt;66%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;pyproject.toml&lt;/td&gt;
    &lt;td class="right-align"&gt;17,245&lt;/td&gt;
    &lt;td class="percent" style="background-size: 55% 100%"&gt;55%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;setup.cfg&lt;/td&gt;
    &lt;td class="right-align"&gt;10,406&lt;/td&gt;
    &lt;td class="percent" style="background-size: 33% 100%"&gt;33%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;b&gt;Total&lt;/b&gt;&lt;/td&gt;
    &lt;td class="right-align"&gt;&lt;b&gt;31,474&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;b&gt;-&lt;/b&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;Pyproject.toml&lt;/h3&gt;
&lt;p&gt;One of the big pushes in python is for adoption of pyproject.toml. So how is that going out there in the real world?&lt;/p&gt;
&lt;p&gt;First of all, it is worth reviewing some of the ways pyproject.toml is or can be used.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://peps.python.org/pep-0517/"&gt;PEP 517&lt;/a&gt; Defines a way to declare a package build backend in pyproject.toml.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://peps.python.org/pep-0621/"&gt;PEP 621&lt;/a&gt; Defines a way to define the package metadata in pyproject.toml.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://peps.python.org/pep-0518/"&gt;PEP 518&lt;/a&gt; Defines a way to declare package build requirements in pyproject.toml and a way for python tools (which may or may not be related to packaging) to store configuration in the &lt;code&gt;tool.*&lt;/code&gt; namespace. Many python tools like pytest, black, mypy, etc allow their configuration to be stored in pyproject.toml using the &lt;code&gt;tool.*&lt;/code&gt; namespace.&lt;/li&gt;
&lt;li&gt;In particular, poetry allows package metadata to be specified in pyproject.toml in a &lt;code&gt;tool.poetry&lt;/code&gt; declaration, but predates and does not conform to PEP 621. I'm going to consider poetry separately.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A point to note here is that these can be combined in various ways. For example, it is possible to declare a build backend in pyproject.toml following PEP 517 and also declare PEP 621 package metadata. However using setuptools it is also possible to declare a build backend in pyproject.toml but specify the rest of the package metadata in setup.py or setup.cfg. Some repos only use pyproject.toml for storing linter configuration and everything to do with packaging is stored in setup.py or setup.cfg. Some repos specify package metadata in pyproject.toml (either following PEP 621 or using poetry), but don't declare a build system. One does not necessarily imply another. I found examples of pretty much every combination. This makes it difficult to conduct a completely coherent analysis or arrive at universally valid assumptions.&lt;/p&gt;
&lt;p&gt;In the sample of repos I looked at 17,245 (55%) contained a pyproject.toml file. 15,754 (91%) of those declare a build backend, requirements, and/or package metadata. 1,497 (9%) did not contain any of those things. Presumably in basically all of those cases, pyproject.toml is being used exclusively as a configuration file for dev tooling.&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Feature&lt;/th&gt;
    &lt;th&gt;Count&lt;/th&gt;
    &lt;th&gt;Percent&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Has build requirements&lt;/td&gt;
    &lt;td class="right-align"&gt;15,427&lt;/td&gt;
    &lt;td class="percent" style="background-size: 89% 100%"&gt;89%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Has build backend&lt;/td&gt;
    &lt;td class="right-align"&gt;14,328&lt;/td&gt;
    &lt;td class="percent" style="background-size: 83% 100%"&gt;83%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Has PEP 621 metadata&lt;/td&gt;
    &lt;td class="right-align"&gt;6,563&lt;/td&gt;
    &lt;td class="percent" style="background-size: 38% 100%"&gt;38%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Has Poetry metadata&lt;/td&gt;
    &lt;td class="right-align"&gt;4,890&lt;/td&gt;
    &lt;td class="percent" style="background-size: 28% 100%"&gt;28%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Has no packaging metadata&lt;/td&gt;
    &lt;td class="right-align"&gt;1,497&lt;/td&gt;
    &lt;td class="percent" style="background-size: 9% 100%"&gt;9%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;b&gt;Total&lt;/b&gt;&lt;/td&gt;
    &lt;td class="right-align"&gt;&lt;b&gt;17,245&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;b&gt;-&lt;/b&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;There are a few interesting results here. The first is that most repos containing a pyproject.toml declare either a build backend and/or requirements. I was actually surprised that more files declare build requirements than a build backend. I expected repos declaring build requirements would basically be a subset of those declaring a build backend. Turns out the inverse is true.&lt;/p&gt;
&lt;p&gt;Many repos are declaring package metadata in pyproject.toml using either PEP 621 or Poetry format, but adoption of pyproject.toml for this purpose is less common.&lt;/p&gt;
&lt;p&gt;My hunch is that a lot of the repos which are only specifying build backend/requirements may have adopted pyproject.toml primarily as a configuration format (as opposed to a package manifest format) and then added a minimal &lt;code&gt;build-system&lt;/code&gt; declaration for compatibility purposes. However that is just my conjecture.&lt;/p&gt;
&lt;h3&gt;Setup.py and setup.cfg&lt;/h3&gt;
&lt;p&gt;The oldest way to specify package metadata is using setup.py. This has served the community well for many years, but the package metadata is mixed with executable python code. The python community's first attempt at a declarative manifest format was setup.cfg. This was a format specific to setuptools rather than a standard and the setuptools project plans to &lt;a href="https://github.com/pypa/setuptools/issues/3214"&gt;eventually deprecate&lt;/a&gt; setup.cfg. One of the big pushes in python is for moving away from setup.py and setup.cfg to specify package metadata, and towards pyproject.toml. So how is that going out there in the real world?&lt;/p&gt;
&lt;p&gt;Of the repos I looked at, 20,684 (66%) contained a setup.py and 10,406 (33%) contained a setup.cfg file. Many contained both. As with pyproject.toml, presence or absence of the file in a repo doesn't necessarily tell us the full story. Some repos that are primarily using pyproject.toml also have a stub setup.py that just contains&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;setuptools&lt;/span&gt;
&lt;span class="n"&gt;setuptools&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;for backwards compatibility reasons. This may be needed, for example for compatibility with tools that don't support &lt;a href="https://peps.python.org/pep-0660/"&gt;PEP 660&lt;/a&gt; editable installs.&lt;/p&gt;
&lt;p&gt;As with pyproject.toml, many python based tools like isort and flake8 allow their configuration to be stored in setup.cfg so some repos contain a setup.cfg but aren't using to store any information related to packaging - it is just there to store linter configuration. Again, basically every combination of scenarios exists in the sample of repos I looked at.&lt;/p&gt;
&lt;p&gt;I haven't attempted to parse the setup.py and setup.cfg files. I am perhaps missing a bit of nuance here, but I have made some assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A repo which declares poetry or PEP 621 package metadata in pyproject.toml is using pyproject.toml as the package manifest.&lt;/li&gt;
&lt;li&gt;A repo that has a setup.py but not a setup.cfg and either doesn't have a pyproject.toml at all or has a pyproject.toml which does not contain poetry or PEP 621 package metadata is using setup.py as the package manifest.&lt;/li&gt;
&lt;li&gt;A repo that has a setup.py and setup.cfg and either doesn't have a pyproject.toml at all or has a pyproject.toml which does not contain poetry or PEP 621 package metadata is using setup.py or setup.cfg as the package manifest.&lt;/li&gt;
&lt;li&gt;There were also just over 1,000 repos doing some other combination of things. A lot of these were a pyproject.toml declaring a build system or build requirements only, with metadata in setup.cfg. I didn't attempt to break them down any further.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Manifest type&lt;/th&gt;
    &lt;th&gt;Count&lt;/th&gt;
    &lt;th&gt;Percent&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;pyproject.toml with metadata&lt;/td&gt;
    &lt;td class="right-align"&gt;11,349&lt;/td&gt;
    &lt;td class="percent" style="background-size: 36% 100%"&gt;36%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;setup.py only&lt;/td&gt;
    &lt;td class="right-align"&gt;10,695&lt;/td&gt;
    &lt;td class="percent" style="background-size: 34% 100%"&gt;34%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;setup.py and setup.cfg&lt;/td&gt;
    &lt;td class="right-align"&gt;8,235&lt;/td&gt;
    &lt;td class="percent" style="background-size: 26% 100%"&gt;26%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Other&lt;/td&gt;
    &lt;td class="right-align"&gt;1,195&lt;/td&gt;
    &lt;td class="percent" style="background-size: 4% 100%"&gt;4%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;b&gt;Total&lt;/b&gt;&lt;/td&gt;
    &lt;td class="right-align"&gt;&lt;b&gt;31,474&lt;/b&gt;&lt;/td&gt;
    &lt;td class="percent" style="background-size: 100% 100%"&gt;&lt;b&gt;100%&lt;/b&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;18,930 (63%) of the repos I looked at are sticking with setup.py and/or setup.cfg as the package manifest.&lt;/p&gt;
&lt;p&gt;Using only a setup.py is still a very popular method of packaging at 34%. This is nearly equal with storing package metadata in pyproject.toml at 36%, despite efforts to transition the community away from executable package manifests and towards declarative manifest formats.&lt;/p&gt;
&lt;h3&gt;Build Backends&lt;/h3&gt;
&lt;p&gt;14,328 of the repos I looked at are using a pyproject.toml that declares a PEP-517 build backend. So next I dug into that. Which build backends are these repos using?&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Build backend&lt;/th&gt;
    &lt;th&gt;Count&lt;/th&gt;
    &lt;th&gt;Percent&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Setuptools&lt;/td&gt;
    &lt;td class="right-align"&gt;6,732&lt;/td&gt;
    &lt;td class="percent" style="background-size: 47% 100%"&gt;47%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Poetry&lt;/td&gt;
    &lt;td class="right-align"&gt;4,671&lt;/td&gt;
    &lt;td class="percent" style="background-size: 33% 100%"&gt;33%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Hatch&lt;/td&gt;
    &lt;td class="right-align"&gt;1,592&lt;/td&gt;
    &lt;td class="percent" style="background-size: 11% 100%"&gt;11%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Flit&lt;/td&gt;
    &lt;td class="right-align"&gt;687&lt;/td&gt;
    &lt;td class="percent" style="background-size: 5% 100%"&gt;5%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Other&lt;/td&gt;
    &lt;td class="right-align"&gt;223&lt;/td&gt;
    &lt;td class="percent" style="background-size: 2% 100%"&gt;2%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Pdm&lt;/td&gt;
    &lt;td class="right-align"&gt;215&lt;/td&gt;
    &lt;td class="percent" style="background-size: 2% 100%"&gt;2%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Maturin&lt;/td&gt;
    &lt;td class="right-align"&gt;208&lt;/td&gt;
    &lt;td class="percent" style="background-size: 1% 100%"&gt;1%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;b&gt;Total&lt;/b&gt;&lt;/td&gt;
    &lt;td class="right-align"&gt;&lt;b&gt;14,328&lt;/b&gt;&lt;/td&gt;
    &lt;td class="percent" style="background-size: 100% 100%"&gt;&lt;b&gt;100%&lt;/b&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;There are more interesting findings here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Among repos using pyproject.toml, setuptools is the by far the most commonly declared build backend, accounting for nearly half the repos I looked at.&lt;/li&gt;
&lt;li&gt;New shiny tools like poetry, hatch and flit have some adoption, but account for a much smaller share of the ecosystem.&lt;/li&gt;
&lt;li&gt;By far the most widely used of these more modern packaging tools is poetry, accounting for 33% of the repos I looked at declaring a build backend in pyproject.toml.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Setuptools&lt;/h3&gt;
&lt;p&gt;Finally, I wanted to look at those repos using setuptools and pyproject.toml. Broadly, these are going to divide into 2 camps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Those specifying package metadata in pyproject.toml, following PEP-621&lt;/li&gt;
&lt;li&gt;Those specifying a build backend only in pyproject.toml, following PEP-517, but storing the package metadata in setup.py or setup.cfg.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Metadata location&lt;/th&gt;
    &lt;th&gt;Count&lt;/th&gt;
    &lt;th&gt;Percent&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Outside pyproject.toml&lt;/td&gt;
    &lt;td class="right-align"&gt;3,615&lt;/td&gt;
    &lt;td class="percent" style="background-size: 54% 100%"&gt;54%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Inside pyproject.toml (PEP-621)&lt;/td&gt;
    &lt;td class="right-align"&gt;3,117&lt;/td&gt;
    &lt;td class="percent" style="background-size: 46% 100%"&gt;46%&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;b&gt;Total&lt;/b&gt;&lt;/td&gt;
    &lt;td class="right-align"&gt;&lt;b&gt;6,732&lt;/b&gt;&lt;/td&gt;
    &lt;td class="percent" style="background-size: 100% 100%"&gt;&lt;b&gt;100%&lt;/b&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Among repos using setuptools and pyproject.toml, only a minority have adopted PEP-621 for declaring package metadata. In the sample of repos I looked at which declare setuptools as a build backend in pyproject.toml, the most popular approach (albeit by a small margin) is to declare only the build backend details in pyproject.toml and store the package metadata elsewhere.&lt;/p&gt;
&lt;h3&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;Based on the analysis I've done here, it seems reasonable to say that adoption of pyproject.toml has been slow, particularly as a package manifest format. Most of the repos I looked at are only or primarily using setup.py and/or setup.cfg. Modern packaging tools are generating blog posts, debate, and mindshare. Out there in the real world we are seeing limited adoption in comparison to more traditional approaches. While a blog post about setuptools is less likely to hit the front page of hackernews, setuptools is the real workhorse when it comes to getting packages shipped.&lt;/p&gt;
&lt;p&gt;As noted at the start of this article, python packaging is a confusing and fragmented space at the moment. There are a lot of ways to skin this cat. It seems reasonable to infer that as a response to this, many developers are choosing to stick with an existing working solution, rather than make sense of the chaos. Who can blame them?&lt;/p&gt;
&lt;p&gt;The python community often moves slowly in response to change. For example the migration from python 2 to 3 dragged on for about a decade, but in that case the direction of travel was at least clear. There was a single linear path. When it comes to modernizing the packaging space, progress is also hindered by the fact that for some projects there are many possible directions of travel. For some projects, there are still zero. Perhaps this is a journey that will take even longer to shake out.&lt;/p&gt;
&lt;h3 id="methodology-notes"&gt;Methodology notes&lt;/h3&gt;

&lt;p&gt;This research was based on a convenience sample. I looked at a selection of repos that made it quick and easy to harvest data, rather than the most robust sample or a complete census of PyPI.&lt;/p&gt;
&lt;p&gt;As a starting point, I used the 2023-10-22 &lt;a href="https://packages.ecosyste.ms/open-data"&gt;Ecosyste.ms Open Data&lt;/a&gt; Release (which is licensed under &lt;a href="https://creativecommons.org/licenses/by-sa/4.0/"&gt;CC BY-SA 4.0&lt;/a&gt; ). This was an easy place to get a bulk list of python packages with GitHub repos attached. I then applied a few filters.&lt;/p&gt;
&lt;p&gt;First I excluded any packages which didn't have one or more releases published inside 2023. I'm really looking into modern packaging practices, so packages without a recent release are less useful to consider here.&lt;/p&gt;
&lt;p&gt;Then I excluded any packages that had less than 100 downloads in the last month. There is a lot of junk on PyPI. This is a low bar for popularity, but I wanted to apply some kind of measure of "someone is actually using this code for something". Applying even this modest filter excluded a surprisingly large number of packages.&lt;/p&gt;
&lt;p&gt;Then finally, I looked only at packages which had a GitHub repo attached to them in the Ecosyste.ms data. This was mainly about making it easy to fetch data in bulk. This means I excluded repos hosted on GitLab, BitBucket, CodeBerg, etc from this analysis. I also did not attempt to look at packages that had no &lt;code&gt;repository_url&lt;/code&gt; attached in the data. As such, the sample contains some blind spots.&lt;/p&gt;
&lt;p&gt;After de-duplicating, this gave me 35,732 GitHub repository URLs.&lt;/p&gt;
&lt;p&gt;I then used the GitHub GraphQL API to attempt to fetch a setup.py, setup.cfg and pyproject.toml if they existed in the repo root. After excluding any repos that were private, did not exist at all, or repos that didn't contain any of those files in the root, I was left with the 31,474 repos that formed the basis of this analysis. Another obvious blind spot here is repos that host a package in a subdirectory instead of the repo root. Those will have been excluded too.&lt;/p&gt;
&lt;p&gt;Finally, I grabbed whatever files were at the &lt;code&gt;HEAD&lt;/code&gt; of the default branch in GitHub. I didn't attempt to find a latest release, or the release that would have been current at the time of the ecosyste.ms open data release. I don't think this makes a huge difference, but it is worth noting.&lt;/p&gt;
&lt;h3&gt;Future work&lt;/h3&gt;
&lt;p&gt;This has been an interesting process, but it only represents a snapshot in a landscape that is shifting over time. I'd like to repeat this analysis again in future to see how the things have changed. It's been a blast. Let's do it again some time.&lt;/p&gt;</description><category>packaging</category><category>python</category><guid>https://chris48s.github.io/blogmarks/posts/2024/python-package-manifest-files/</guid><pubDate>Sat, 17 Feb 2024 00:00:00 GMT</pubDate></item><item><title>pip 20.3</title><link>https://chris48s.github.io/blogmarks/posts/2020/pip-203/</link><dc:creator>chris48s</dc:creator><description>&lt;p&gt;There is a very long-standing issue on the pip repository: &lt;a href="https://github.com/pypa/pip/issues/988"&gt;pip needs a dependency resolver&lt;/a&gt;. Most language package managers (e.g: composer, bundler, cargo, etc) either use a resolver to derive a consistent dependency tree and prevent incompatible installations, or in the case of NPM/yarn allow "broken diamond" resolution (where more than one version of the same package can be installed at the same time). For the longest time, pip has had no true resolver, allowing incompatible dependencies to be installed. Until now..&lt;/p&gt;
&lt;p&gt;Today's release of &lt;a href="https://blog.python.org/2020/11/pip-20-3-release-new-resolver.html"&gt;Pip 20.3&lt;/a&gt; is the culmination of a &lt;a href="https://pyfound.blogspot.com/2020/03/new-pip-resolver-to-roll-out-this-year.html"&gt;long programme of work&lt;/a&gt; to implement a proper dependency resolver in pip. This makes pip 20.3 the most significant pip release in a very long time, possibly ever.&lt;/p&gt;
&lt;p&gt;It has actually been possible to preview this feature for some time using the &lt;code&gt;--use-feature=2020-resolver&lt;/code&gt; flag in pip 20.2.x or by installing the beta releases of pip 20.3, but pip 20.3 is the first stable release to enable the new resolver by default. This means that a command like:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;pip&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;virtualenv&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;20&lt;/span&gt;.0.2&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;six&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.11
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;printf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"virtualenv==20.0.2\nsix==1.11"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;requirements.txt
pip&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;-r&lt;span class="w"&gt; &lt;/span&gt;requirements.txt
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;will now not install any new packages and throw a helpful error like:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ERROR: Cannot install six==1.11 and virtualenv==20.0.2 because these package versions have conflicting dependencies.

The conflict is caused by:
    The user requested six==1.11
    virtualenv 20.0.2 depends on six&amp;lt;2 and &amp;gt;=1.12.0

To fix this you could try to:
1. loosen the range of package versions you've specified
2. remove package versions to allow pip attempt to solve the dependency conflict

ERROR: ResolutionImpossible: for help visit https://pip.pypa.io/en/latest/user_guide/#fixing-conflicting-dependencies
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;which is a &lt;em&gt;massive&lt;/em&gt; improvement over the previous behaviour. There is a gotcha though. Resolution only considers the packages being installed in that command. It doesn't take into account other packages already installed in your (virtual) environment. This means running&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;pip&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;virtualenv&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;20&lt;/span&gt;.0.2&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;pip&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;six&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.11
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;doesn't fail to install &lt;code&gt;six==1.11&lt;/code&gt; with a &lt;code&gt;ResolutionImpossible&lt;/code&gt; error. It will still install the incompatible package and warn you that it has done that:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.
ERROR: virtualenv 20.0.2 requires six&amp;lt;2,&amp;gt;=1.12.0, but you'll have six 1.11.0 which is incompatible.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This isn't a bug. This behaviour is noted in the error message  and &lt;a href="https://pip.pypa.io/en/latest/user_guide/#changes-to-the-pip-dependency-resolver-in-20-3-2020"&gt;documented in the release notes&lt;/a&gt;, but it is worth understanding this limitation. Even with the new resolver pip will still install incompatible dependencies in your environment if given the right combination of commands. This is a situation it is possible to wander into without realising or consciously enabling the legacy behaviour with &lt;code&gt;--use-deprecated=legacy-resolver&lt;/code&gt;. While it is useful to have some further improved messaging around this, it is still a bit of a disappointment.&lt;/p&gt;
&lt;p&gt;I've &lt;a href="https://chris48s.github.io/blogmarks/posts/2020/2poetry/"&gt;previously written&lt;/a&gt; about poetry. I'm now using poetry for all projects where I'm the only person who works on it and I have no plan to change that (poetry's behaviour is still more advanced here and IMO preferable), but it is impossible to work in the wider python community without encountering pip. This feature reduces that point of friction and it is great to see, but it isn't a silver bullet for preventing incompatible dependencies. It will be interesting to see how the wider community responds as users encounter this behaviour change for the first time.&lt;/p&gt;</description><category>packaging</category><category>python</category><guid>https://chris48s.github.io/blogmarks/posts/2020/pip-203/</guid><pubDate>Mon, 30 Nov 2020 00:00:00 GMT</pubDate></item><item><title>pipx</title><link>https://chris48s.github.io/blogmarks/posts/2020/pipx/</link><dc:creator>chris48s</dc:creator><description>&lt;p&gt;Poetry is my go-to solution for managing libraries and project dependencies in python, but there are also a variety of python-based CLI tools like &lt;a href="https://github.com/aws/aws-cli"&gt;aws-cli&lt;/a&gt; and &lt;a href="https://pypi.org/project/tldr/"&gt;tldr&lt;/a&gt; that I want globally available. But what if they have incompatible dependencies? No worries - &lt;a href="https://pipxproject.github.io/pipx/"&gt;pipx&lt;/a&gt; has got your back. Pipx installs packages into an isolated virtual environment for each application, keeping their dependencies separate and your global environment clean. This makes the applications globally available while avoiding the possibility of conflicts in the global environment.&lt;/p&gt;</description><category>packaging</category><category>python</category><guid>https://chris48s.github.io/blogmarks/posts/2020/pipx/</guid><pubDate>Fri, 14 Aug 2020 23:00:00 GMT</pubDate></item><item><title>Poetry</title><link>https://chris48s.github.io/blogmarks/posts/2020/2poetry/</link><dc:creator>chris48s</dc:creator><description>&lt;p&gt;&lt;a href="https://python-poetry.org/"&gt;Poetry&lt;/a&gt;'s killer feature is consistent deterministic dependency resolution and proper handling of &lt;a href="https://www.well-typed.com/blog/2008/08/solving-the-diamond-dependency-problem/"&gt;the diamond dependency problem&lt;/a&gt;. In most packaging ecosystems, this is table stakes. Sadly in python, &lt;a href="https://github.com/pypa/pip/issues/988"&gt;it still isn't&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A few years ago I migrated some projects to &lt;code&gt;pipenv&lt;/code&gt; hoping it would be the solution I was looking for but, like many others, I quickly hit some roadblocks with this approach.&lt;/p&gt;
&lt;p&gt;I've been using poetry in earnest for around six months and have since migrated all of my active personal projects to use poetry. It is now my go-to solution for dependency installation, virtualenv management and packaging.&lt;/p&gt;
&lt;ul class="no-bullet"&gt;
  &lt;li&gt;
    &lt;i class="fab fa-github"&gt;&lt;/i&gt;
    &lt;a href="https://github.com/python-poetry/poetry"&gt;Github&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;i class="fas fa-book-open"&gt;&lt;/i&gt;
    &lt;a href="https://python-poetry.org/docs/"&gt;Docs&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;</description><category>packaging</category><category>python</category><guid>https://chris48s.github.io/blogmarks/posts/2020/2poetry/</guid><pubDate>Sat, 23 May 2020 00:00:00 GMT</pubDate></item></channel></rss>