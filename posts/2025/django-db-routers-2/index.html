<!DOCTYPE html>
<html prefix="        og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Django DB Routers: Avoiding Race Conditions | Blogmarks</title>
<link href="../../../assets/css/baguetteBox.min.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/custom.css" rel="stylesheet" type="text/css">
<link href="https://use.fontawesome.com/releases/v5.4.1/css/all.css" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../rss.xml">
<link rel="canonical" href="https://chris48s.github.io/blogmarks/posts/2025/django-db-routers-2/">
<!--[if lt IE 9]><script src="../../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="chris48s">
<link rel="prev" href="../django-db-routers-1/" title="Django DB Routers: Pitfalls" type="text/html">
<link rel="next" href="../masto-host-behind-cloudflare/" title="Running masto.host behind CloudFlare" type="text/html">
<meta property="og:site_name" content="Blogmarks">
<meta property="og:title" content="Django DB Routers: Avoiding Race Conditions">
<meta property="og:url" content="https://chris48s.github.io/blogmarks/posts/2025/django-db-routers-2/">
<meta property="og:description" content='If you are using django with a Postgres primary/replica setup for the first time, your first instinct may be to write something like this:
DATABASES = {
    "default": {
        "ENGINE": "django.db.b'>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-04-04T00:00:00+01:00">
<meta property="article:tag" content="django">
<meta property="article:tag" content="python">
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Django DB Routers: Avoiding Race Conditions",
    "url": "https://chris48s.github.io/blogmarks/posts/2025/django-db-routers-2/",
    "description": "",
    "author": {
        "@type": "Person",
        "name": "chris48s"
    },
    "mainEntityOfPage": "https://chris48s.github.io/blogmarks/posts/2025/django-db-routers-2/",
    "datePublished": "2025-04-04",
    "dateCreated": "2025-04-04",
    "dateModified": "2025-04-04"
}
</script>
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
        
    <header id="header"><h1 id="brand"><a href="../../../" title="Blogmarks" rel="home">

        <span id="blog-title">Blogmarks</span>
    </a></h1>

        

        
    <nav id="menu"><ul>
<li><a href="../../../rss.xml">RSS feed</a></li>
                <li><a href="../../../categories/">Tags</a></li>

    

    
    
    </ul></nav></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Django DB Routers: Avoiding Race Conditions</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    chris48s
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2025-04-04T00:00:00+01:00" itemprop="datePublished" title="2025-04-04">2025-04-04</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>If you are using django with a Postgres primary/replica setup for the first time, your first instinct may be to write something like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">DATABASES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"default"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">"ENGINE"</span><span class="p">:</span> <span class="s2">"django.db.backends.postgresql"</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">},</span>
    <span class="s2">"replica1"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">"ENGINE"</span><span class="p">:</span> <span class="s2">"django.db.backends.postgresql"</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">},</span>
    <span class="s2">"replica2"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">"ENGINE"</span><span class="p">:</span> <span class="s2">"django.db.backends.postgresql"</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">},</span>
<span class="p">}</span>


<span class="kn">import</span> <span class="nn">random</span>

<span class="k">class</span> <span class="nc">AuthRouter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">db_for_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">"replica1"</span><span class="p">,</span> <span class="s2">"replica2"</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">db_for_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"default"</span>
    <span class="o">...</span>
</pre></div>

<p>Read from the replicas, write to the primary - simple. There are tutorials online that will tell you to do this.</p>
<p>However, there's a problem with this setup: You now have a race condition. Replication is not instant. If you write something to the primary and then read back the same record from one of the replicas, the data may be stale.</p>
<p>How you choose to solve this depends on your application, but here's one strategy I have recently used.</p>
<p>A site I am working on has essentially a read-only public-facing site with a large number of users. Writes are made either by a handful of internal users via django's admin backend, or by management commands. We want to prevent race conditions in contexts where we will perform writes and scale DB reads in the public-facing parts of the site.</p>
<p>In order to do this, we used a package called <a href="https://pypi.org/project/django-middleware-global-request/">django-middleware-global-request</a>. This package provides a middleware that can store the current request in a thread-local variable so it can be accessed in contexts where a request would not normally be in scope.</p>
<p>Using this package allows us to write the following code:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">django_middleware_global_request</span> <span class="kn">import</span> <span class="n">get_request</span>

<span class="k">class</span> <span class="nc">AuthRouter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">db_for_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="n">request</span> <span class="o">=</span> <span class="n">get_request</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">request</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"/admin"</span><span class="p">):</span>
                <span class="c1"># always read from the primary</span>
                <span class="c1"># in the admin interface</span>
                <span class="k">return</span> <span class="s2">"default"</span>

            <span class="c1"># use replicas to serve read traffic</span>
            <span class="c1"># on the public site</span>
            <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">"replica1"</span><span class="p">,</span> <span class="s2">"replica2"</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># if there's no request in scope,</span>
        <span class="c1"># read from the primary</span>
        <span class="c1"># we don't care about trying to "scale"</span>
        <span class="c1"># management commands</span>
        <span class="k">return</span> <span class="s2">"default"</span>

    <span class="k">def</span> <span class="nf">db_for_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"default"</span>
    <span class="o">...</span>
</pre></div>

<p>There are some situations where this wouldn't work. Obviously if you can't generalise about traffic based on the URL this strategy isn't going to hold water. Perhaps less obviously, if you've got an application which uses a lot of background tasks (which also will not have a request in scope) you might want to also serve some reads from the replicas in that situation. This approach would serve all the reads from the primary in that context.</p>
<p>For my use-case, this worked like a charm.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/django/" rel="tag">django</a></li>
            <li><a class="tag p-category" href="../../../categories/python/" rel="tag">python</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../django-db-routers-1/" rel="prev" title="Django DB Routers: Pitfalls">Previous post</a>
            </li>
            <li class="next">
                <a href="../masto-host-behind-cloudflare/" rel="next" title="Running masto.host behind CloudFlare">Next post</a>
            </li>
        </ul></nav></aside></article></main><footer id="footer"><p>
</p>
<p>Contents © 2025 chris48s</p>

<ul class="no-bullet">
<li>
    <i class="fab fa-github"></i>
    <a href="https://github.com/chris48s/" target="_blank">Github</a>
  </li>
  <li>
    <i class="fab fa-mastodon"></i>
    <a href="https://fed.chris-shaw.dev/@chris" target="_blank">Mastodon</a>
  </li>
</ul></footer>
</div>
    
            <script src="../../../assets/js/baguetteBox.min.js"></script><script>
    baguetteBox.run('main#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
